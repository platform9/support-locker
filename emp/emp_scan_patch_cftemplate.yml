AWSTemplateFormatVersion: 2010-09-09
Description: "Platform9 EMP EC2 BM Instance Assessment & Patching in US-EAST-1"
Parameters:
  IsPolicyAttachAllowed:
    Type: String
    Default: 'true'
    AllowedValues:
      - 'true'
      - 'false'
    Description: >-
      (Optional) Whether Quicksetup is allowed to attach policies to existing Instance profiles.
  HasDeletedBaseline:
    Type: String
    Default: 'false'
    AllowedValues:
      - 'true'
      - 'false'
    Description: (Optional) Whether patch policy contains a deleted custom patch baseline.
  QSType:
    Type: String
    AllowedValues:
      - LA
      - TA
      - MA
    Default: LA
    Description: >-
      (Required) Specifies the type of target for the Quick Setup configuration: local account only (?LA?), some or all organizational units (?TA?), or management account only (?MA?).
  QSConfigurationId:
    Type: String
    Default: 'pf9'
    Description: (Required) The unique identifier of the deployed configuration.
  QSConfigurationName:
    Type: String
    Default: 'Pf9EMPAutoPatch'
    Description: (Required) The name of the configuration.
  InspectorNamePrefix:
    Type: String
    Description: >-
      The prefix for names used for Inspectoe resources.
    Default: 'Pf9EMP'
  SelectedPatchBaselines:
    Type: String
    Default: ''
    Description: Stringified JSON content of selected Patch baselines.
  PatchBaselineUseDefault:
    Type: String
    Default: default
    AllowedValues:
      - default
      - custom
    Description: >-
      Indicates whether all the selected patch baselines are AWS predefined baselines.
  ConfigurationOptionsPatchOperation:
    Type: String
    Default: ScanAndInstall
    AllowedValues:
      - Scan
      - ScanAndInstall
    Description: (Required) Whether to scan for patches or install patches.
  RateControlErrorThreshold:
    Type: String
    Default: '1'
    Description: >-
      The number of errors that are allowed before the system stops sending requests to run the association on additional targets.
  RateControlConcurrency:
    Type: String
    Default: '1'
    Description: >-
      Indicates the maximum number of target nodes where the patching operation can run at a time.
  ConfigurationOptionsScanValue:
    Type: String
    Default: cron(0 1 ? * SUN *)
    Description: >-
      (Optional) A cron expression to define a schedule for the Scan operation, or a rate expression to define the frequency for the operation.
  ConfigurationOptionsScanNextInterval:
    Type: String
    Default: 'true'
    AllowedValues:
      - 'true'
      - 'false'
    Description: >-
      Whether or not to run the State Manager scan associations on next CRON interval.
  ConfigurationOptionsInstallValue:
    Type: String
    Default: cron(0 2 ? * SUN *)
    Description: >-
      (Optional) A cron expression to define a schedule for the Install operation, or a rate expression to define the frequency for the operation.
  ConfigurationOptionsInstallNextInterval:
    Type: String
    Default: 'true'
    AllowedValues:
      - 'true'
      - 'false'
    Description: >-
      Whether or not to run the State Manager install associations on next CRON interval.
  OutputLogEnableS3:
    Type: String
    Default: 'false'
    AllowedValues:
      - 'true'
      - 'false'
    Description: (Optional) Whether or not to send output to s3 bucket.
  OutputBucketRegion:
    Type: String
    Default: ''
    Description: >-
      (Required) The ID of the Region where the S3 bucket for storing command output logs is located.
  OutputS3BucketName:
    Type: String
    Description: The name of the S3 bucket where command output logs are stored.
    AllowedPattern: '^[a-z0-9.-]{0,63}$'
    Default: ''
  OutputS3KeyPrefix:
    Type: String
    Description: >-
      The directory structure in the S3 bucket where command output logs are stored.
    Default: ''
  TargetType:
    Type: String
    Default: Tags
    AllowedValues:
      - Tags
      - InstanceIds
      - ResourceGroups
      - '*'
    Description: >-
      (Optional) Indicates the method by which nodes are targeted. Applies to configurations for local accounts only.
  TargetInstances:
    Type: String
    Default: '*'
    Description: >-
      (Optional) Specifies the nodes to target when QSType=LA and ScanTargetType=InstanceIds.
  ResourceGroupName:
    Type: String
    Default: ''
    Description: >-
      (Optional) Specifies the name of the resource group to target when QSType=LA or QSType=TA and ScanTargetType=ResourceGroups.
  RebootOption:
    Type: String
    Default: NoReboot
    AllowedValues:
      - RebootIfNeeded
      - NoReboot
    Description: >-
      (Optional) Reboot behavior after a patch Install operation. If you choose NoReboot and patches are installed, the node is marked as noncompliant until a subsequent reboot and scan.
  TargetTagKey:
    Type: String
    Default: 'pf9_patch_key'
    Description: >-
      (Optional) Specifies the tag key that is applied to the nodes being targeted when QSType=LA or QSType=TA and ScanTargetType=Tags.
  TargetTagValue:
    Type: String
    Default: 'rsz0qjo7wt5uxq3'
    Description: >-
      (Optional) Specifies the tag value that is applied to the nodes being targeted when QSType=LA or QSType=TA and ScanTargetType=Tags.
  PatchBaselineRegion:
    Type: String
    Default: ''
    Description: (Required) The region from which Patch Baselines are pulled
  AccountId:
    Type: String
    Default: ''
    Description: >-
      (Required) Account Id that owns the S3 bucket for baseline_overrides.json object
  TargetEntities:
    Type: String
    Default: LOCAL
    AllowedValues:
      - ENTIRE_ORG
      - OU
      - LOCAL
    Description: (Required) Specifies the target entities
  OUs:
    Type: CommaDelimitedList
    Default: ''
    Description: >-
      (Optional) A list of all Organizational Units (OUs) targeted for deployment
  OrgId:
    Type: String
    Default: ''
    Description: (Optional) Principal Organization Id of the AWS Organization
Conditions:
  PolicyAttachAllowed: !Equals
    - !Ref IsPolicyAttachAllowed
    - 'true'
  IsGlobalRegion: !Equals
    - !Ref 'AWS::Region'
    - !Ref 'AWS::Region'
  DeployManagementResources: !And
    - !Condition IsGlobalRegion
    - !Equals
      - !Ref QSType
      - LA
  CreateInstallInstancesAssociation: !Equals
    - !Ref ConfigurationOptionsPatchOperation
    - ScanAndInstall
  EnabledOutputBucketWithPrefix: !And
    - !Equals
      - !Ref OutputLogEnableS3
      - 'true'
    - !Not
      - !Equals
        - !Ref OutputS3KeyPrefix
        - ''
  EnabledOutputBucketWithoutPrefix: !And
    - !Equals
      - !Ref OutputLogEnableS3
      - 'true'
    - !Equals
      - !Ref OutputS3KeyPrefix
      - ''
  IsTagValueNotSpecified: !Equals
    - !Ref TargetTagValue
    - ''
  IsTagKeyAndValueTargeted: !And
    - !Equals
      - !Ref TargetType
      - Tags
    - !Not
      - !Condition IsTagValueNotSpecified
  IsTagKeyOnlyTargeted: !And
    - !Equals
      - !Ref TargetType
      - Tags
    - !Condition IsTagValueNotSpecified
  IsResourceGroupTargeted: !Equals
    - !Ref TargetType
    - ResourceGroups
  TargetAll: !Equals
    - !Ref TargetInstances
    - '*'
Resources:
  CwEventAutoAssessment:
    Type: "AWS::Events::Rule"
    Properties:
      Name: !Sub '${InspectorNamePrefix}ScheduledAssessment-${AWS::Region}'
      Description: "Scheduled trigger for Amazon Inspector Assessment: Pf9EMPAutoAssessment"
      State: "ENABLED"
      Targets:
        - Arn:
            Ref: "AssessmentTemplate"
          Id: "AmazonInspectorAssessment"
          RoleArn:
            Fn::GetAtt:
              - "AutoAssessmentIamRole"
              - "Arn"
      ScheduleExpression: cron(00 03 ? * SUN *)
  AssessmentTarget:
    Type: "AWS::Inspector::AssessmentTarget"
    Properties:
      AssessmentTargetName: !Sub '${InspectorNamePrefix}Targets-${AWS::Region}'
      ResourceGroupArn:
        Ref: "ResourceGroup"
  ResourceGroup:
    Type: "AWS::Inspector::ResourceGroup"
    Properties:
      ResourceGroupTags:
        - Key: !Ref TargetTagKey
          Value: !Ref TargetTagValue
  AssessmentTemplate:
    Type: "AWS::Inspector::AssessmentTemplate"
    Properties:
      AssessmentTargetArn:
        Ref: "AssessmentTarget"
      DurationInSeconds: 3600
      RulesPackageArns:
        - Fn::FindInMap:
            - "RulePackageArn"
            - Ref: "AWS::Region"
            - "CVE"
        - Fn::FindInMap:
            - "RulePackageArn"
            - Ref: "AWS::Region"
            - "CIS"
        - Fn::FindInMap:
            - "RulePackageArn"
            - Ref: "AWS::Region"
            - "Network"
        - Fn::FindInMap:
            - "RulePackageArn"
            - Ref: "AWS::Region"
            - "Security"
        - Fn::FindInMap:
            - "RulePackageArn"
            - Ref: "AWS::Region"
            - "Runtime"
      AssessmentTemplateName: !Sub '${InspectorNamePrefix}AutoAssessment-${AWS::Region}'
  AutoAssessmentIamRole:
    Type: "AWS::IAM::Role"
    Properties:
      RoleName: !Sub 'AWS_InspectorEvents_Invoke_Assessment_Template-${AWS::Region}-${QSConfigurationId}'
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: "Allow"
            Principal:
              Service:
                - "events.amazonaws.com"
            Action:
              - "sts:AssumeRole"
      Policies:
        - PolicyName: !Sub 'InspectorAssessmentTrigger'
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: "Allow"
                Action:
                  - "inspector:StartAssessmentRun"
                Resource: "*"
  BaselineOverridesAccessLogBucket:
    Type: 'AWS::S3::Bucket'
    Properties:
      BucketName: !Join
        - '-'
        - - !Sub 'aws-quicksetup-patchpolicy-access-log-${AWS::AccountId}'
          - !Select
            - 3
            - !Split
              - '-'
              - !Select
                - 2
                - !Split
                  - /
                  - !Ref 'AWS::StackId'
          - !Ref QSConfigurationId
      AccessControl: Private
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      LifecycleConfiguration:
        Rules:
          - Id: MoveToGlacierAfter90Days_DeleteAfter10Years
            ExpirationInDays: 3653
            Status: Enabled
            Transitions:
              - StorageClass: GLACIER_IR
                TransitionInDays: 90
      OwnershipControls:
        Rules:
          - ObjectOwnership: BucketOwnerEnforced
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: Enabled
    DeletionPolicy: Delete
    Condition: DeployManagementResources
  BaselineOverridesAccessLogBucketPolicy:
    Type: 'AWS::S3::BucketPolicy'
    Properties:
      Bucket: !Ref BaselineOverridesAccessLogBucket
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Sid: DenyInsecureTransport
            Effect: Deny
            Principal: '*'
            Action: 's3:*'
            Resource:
              - !Sub 'arn:${AWS::Partition}:s3:::${BaselineOverridesAccessLogBucket}'
              - !Sub 'arn:${AWS::Partition}:s3:::${BaselineOverridesAccessLogBucket}/*'
            Condition:
              Bool:
                'aws:SecureTransport': 'false'
          - Sid: S3ServerAccessLogsPolicy
            Effect: Allow
            Principal:
              Service: logging.s3.amazonaws.com
            Action:
              - 's3:PutObject'
            Resource: !Sub 'arn:${AWS::Partition}:s3:::${BaselineOverridesAccessLogBucket}/*'
            Condition:
              ArnLike:
                'aws:SourceArn': !Sub >-
                  arn:${AWS::Partition}:s3:::aws-quicksetup-patchpolicy-${AWS::AccountId}-${QSConfigurationId}-${AWS::Region}
              StringEquals:
                'aws:SourceAccount': !Sub ${AWS::AccountId}
    Condition: DeployManagementResources
  BaselineOverridesLambdaFunction:
    Type: 'AWS::Lambda::Function'
    Properties:
      FunctionName: !Join
        - '-'
        - - baseline-overrides
          - !Select
            - 3
            - !Split
              - '-'
              - !Select
                - 2
                - !Split
                  - /
                  - !Ref 'AWS::StackId'
          - !Ref QSConfigurationId
      Description: >-
        Lambda function that responds to Delete and Create events from CloudFormation or performs baseline remediation when triggered by the State Manager Association executing the Automation Document
      Code:
        ZipFile: "# Copyright 2022 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# Licensed under the Apache License, Version 2.0 (the 'License'). You\n# may not use this file except in compliance with the License. A copy of\n# the License is located at\n#     http://aws.amazon.com/apache2.0/\n# or in the 'license' file accompanying this file. This file is\n# distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n# ANY KIND, either express or implied. See the License for the specific\n# language governing permissions and limitations under the License.\n#\n# This handler performs CRUD operations on an S3 object.\n# This handler also adds a Quick Setup specific bucket policy to the bucket\n# to enable target nodes to pull down the S3 object during patching operations.\nimport boto3\nimport json\nimport urllib3\nimport time\nimport os\nSUCCESS = 'SUCCESS'\nFAILED = 'FAILED'\n# Events sent in by CloudFormation\nCREATE = 'Create'\nUPDATE = 'Update'\nDELETE = 'Delete'\n# Event sent in by Automation\nREMEDIATE = 'Remediate'\nDEFAULT_REGION = 'us-east-1'\nregion = os.environ['REGION']\ns3_client = boto3.client('s3', region_name=region)\nssm_client = boto3.client('ssm', region_name=region)\ns3_resource = boto3.resource('s3', region_name=region)\nhttp = urllib3.PoolManager()\n# Create a boto3 client for AWS Security Token Service (STS) \nsts_client = boto3.client('sts')\n# Get the AWS Account ID \nresponse = sts_client.get_caller_identity() \nAccountId = response['Account']\ndef create_bucket(bucket_name):\n    bucket_creation_params = {\n        'ACL': 'private',\n        'Bucket': bucket_name,\n        'CreateBucketConfiguration': {\n            'LocationConstraint': region\n        },\n        'ObjectOwnership': 'BucketOwnerEnforced'\n    }\n    if region == DEFAULT_REGION:\n        del bucket_creation_params['CreateBucketConfiguration']\n        print('Creating a bucket in', DEFAULT_REGION, '...', '\\n')\n    else:\n        print('Creating a bucket in', region, '...', '\\n')\n    s3_client.create_bucket(**bucket_creation_params)\n    waiter = s3_client.get_waiter('bucket_exists')\n    waiter.wait(Bucket=bucket_name)\n    print('Successfully created the bucket:', bucket_name, '\\n')\n\n\ndef put_bucket_versioning(bucket_name):\n\n    print('Enabling bucket versioning... \\n')\n    s3_client.put_bucket_versioning(\n        Bucket=bucket_name,\n        VersioningConfiguration={\n            'MFADelete': 'Disabled',\n            'Status': 'Enabled'\n        }\n    )\n    print('Bucket versioning enabled \\n')\ndef put_bucket_encryption(bucket_name):\n    print('Applying server side encryption to the bucket... \\n')\n    s3_client.put_bucket_encryption(\n        Bucket=bucket_name,\n        ServerSideEncryptionConfiguration={\n            'Rules': [\n                {\n                    'ApplyServerSideEncryptionByDefault': {\n                        'SSEAlgorithm': 'AES256'\n                    }\n                }\n            ]\n        }\n    )\n    print('Encryption applied to the bucket \\n')\ndef put_public_access_block(bucket_name):\n    print('Turning on public access block for the bucket... \\n')\n    s3_client.put_public_access_block(\n        Bucket=bucket_name,\n        PublicAccessBlockConfiguration={\n            'BlockPublicAcls': True,\n            'IgnorePublicAcls': True,\n            'BlockPublicPolicy': True,\n            'RestrictPublicBuckets': True\n        }\n    )\n    print('Public access block turned on for the bucket \\n')\ndef put_bucket_lifecycle_configuration(bucket_name):\n    print('Applying lifecycle configuration to the bucket... \\n')\n    s3_client.put_bucket_lifecycle_configuration(\n        Bucket=bucket_name,\n        LifecycleConfiguration={\n            'Rules': [\n                {\n                    'ID': 'DeleteVersionsOlderThan90Days',\n                    'Filter': {\n                        'Prefix': 'baseline_overrides.json'\n                    },\n                    'Status': 'Enabled',\n                    'NoncurrentVersionExpiration': {\n                        'NoncurrentDays': 90\n                    }\n                }\n            ]\n        }\n    )\n    print('Lifecycle configuration applied to the bucket \\n')\ndef put_bucket_policy(bucket_name, resource_properties):\n    print('Constructing and applying bucket policy... \\n')\n    partition = resource_properties['Partition']\n    baseline_overrides_json = f'arn:{partition}:s3:::{bucket_name}/baseline_overrides.json'\n    qs_configuration_id = resource_properties['QSConfigId']\n    target_entities = resource_properties['TargetEntities']\n    organizational_units = resource_properties['OrgUnits']\n    principal_org_id = resource_properties['PrincipalOrgId']\n    account_id = resource_properties['AccountId']\n    bucket_policy = {\n        'Version': '2012-10-17',\n        'Statement': [\n            {\n                'Sid': 'DenyInsecureTransport',\n                'Effect': 'Deny',\n                'Principal': '*',\n                'Action': 's3:*',\n                'Resource': [\n                    f'arn:{partition}:s3:::{bucket_name}/*'\n                ],\n                'Condition': {\n                    'Bool': {\n                        'aws:SecureTransport': 'false'\n                    }\n                }\n            },\n            {\n                'Sid': 'DenyAllButPrincipalsWithTag',\n                'Effect': 'Deny',\n                'Principal': {\n                    'AWS': '*'\n                },\n                'Action': 's3:GetObject',\n                'Resource': [\n                    baseline_overrides_json\n                ],\n                'Condition': {\n                    'StringNotEquals': {\n                        f'aws:PrincipalTag/QSConfigId-{qs_configuration_id}': f'{qs_configuration_id}'\n                    }\n                }\n            }\n        ]\n    }\n    target_statement = {\n        'Sid': 'Target',\n        'Effect': 'Allow',\n        'Action': 's3:GetObject',\n        'Resource': baseline_overrides_json\n    }\n    if target_entities.upper() == 'OU':\n        if len(organizational_units) == 0:\n            raise ValueError('Was expecting at least one OU')\n        principal_org_paths = [\n            f'{principal_org_id}/*/{ou}/*' for ou in organizational_units if ou.startswith('ou-')]\n        if len(principal_org_paths) == 0:\n            raise ValueError('Was expecting at least one OU')\n        target_statement['Principal'] = '*'\n        target_statement['Condition'] = {\n            'ForAnyValue:StringLike': {\n                'aws:PrincipalOrgPaths': principal_org_paths\n            }\n        }\n    elif target_entities.upper() == 'ENTIRE_ORG':\n        target_statement['Principal'] = '*'\n        target_statement['Condition'] = {\n            'StringEquals': {\n                'aws:PrincipalOrgID': [\n                    f'{principal_org_id}'\n                ]\n            }\n        }\n    elif target_entities.upper() == 'LOCAL':\n        target_statement['Principal'] = {\"AWS\": account_id}\n    else:\n        raise ValueError(\n            'Got an unexpected value for target entities; was expecting ENTIRE_ORG, LOCAL, or OU')\n    bucket_policy['Statement'].append(target_statement)\n    s3_client.put_bucket_policy(\n        Bucket=bucket_name,\n        Policy=json.dumps(bucket_policy)\n    )\n    print('Bucket policy applied \\n')\ndef put_bucket_logging(bucket_name, access_log_bucket_name):\n    print('Enabling logging for the bucket... \\n')\n    s3_client.put_bucket_logging(\n        Bucket=bucket_name,\n        BucketLoggingStatus={\n            'LoggingEnabled': {\n                'TargetBucket': access_log_bucket_name,\n                'TargetPrefix': ''\n            }\n        }\n    )\n    print('Logging enabled for the bucket \\n')\ndef get_patch_baselines(patch_baseline_ids, request_type) -> dict:\n    print('Retrieving patch baselines... \\n')\n    patch_baselines = []\n    non_existent_baseline_ids = []\n    if request_type in (CREATE, UPDATE):\n        try:\n            for baseline_id in patch_baseline_ids:\n                baseline = ssm_client.get_patch_baseline(\n                    BaselineId=baseline_id\n                )\n                patch_baselines.append(baseline)\n            print('Patch baselines retrieved \\n')\n            return {\n                'PatchBaselines': json.dumps(patch_baselines, default=str),\n                'NonExistentBaselineIds': non_existent_baseline_ids\n            }\n        except ssm_client.exceptions.DoesNotExistException as err:\n            print(f'Baseline id {baseline_id} does not exist')\n            print(err, '\\n')\n            raise err\n    elif request_type == REMEDIATE:  # Different behavior for Remediate by design\n        for baseline_id in patch_baseline_ids:\n            try:\n                baseline = ssm_client.get_patch_baseline(\n                    BaselineId=baseline_id\n                )\n                patch_baselines.append(baseline)\n            except ssm_client.exceptions.DoesNotExistException:\n                non_existent_baseline_ids.append(baseline_id)\n        print('Patch baselines retrieved \\n')\n        return {\n            'PatchBaselines': json.dumps(patch_baselines, default=str),\n            'NonExistentBaselineIds': non_existent_baseline_ids\n        }\ndef place_baselines_into_bucket(bucket_name, baselines):\n    print('Loading the baselines... \\n')\n    s3_client.put_object(\n        Body=baselines['PatchBaselines'],\n        Bucket=bucket_name,\n        Key='baseline_overrides.json',\n    )\n    print('Baselines loaded \\n')\n    if baselines['NonExistentBaselineIds']:\n        print('The following baseline ids could not be found:',\n              baselines['NonExistentBaselineIds'], '\\n')\n        raise ValueError(\n            f'The following baseline ids could not be found: {baselines[\"NonExistentBaselineIds\"]}')\ndef permanently_delete_all_objects(bucket_name):\n    print('Deleting all objects in the bucket permanently... \\n')\n    bucket = s3_resource.Bucket(bucket_name)\n    bucket.object_versions.all().delete()\n    time.sleep(2)\n    print('Bucket has been emptied \\n')\ndef delete_bucket(bucket_name):\n    print('Deleting the bucket... \\n')\n    s3_client.delete_bucket(\n        Bucket=bucket_name\n    )\n    waiter = s3_client.get_waiter('bucket_not_exists')\n    waiter.wait(\n        Bucket=bucket_name\n    )\n    print('Bucket deleted successfully \\n')\ndef empty_and_delete_bucket(bucket_name):\n    try:\n        s3_client.head_bucket(\n            Bucket=bucket_name\n        )\n        permanently_delete_all_objects(bucket_name)\n        delete_bucket(bucket_name)\n    except Exception as err:\n        # Bucket does not exist or is not owned by the account\n        if err.response['Error']['Code'] == '404':\n            return\n        else:\n            raise err\ndef send(event, context, responseStatus, responseData=None, physicalResourceId=None, noEcho=False, reason=None):\n    request_type = event.get('RequestType')\n    if not request_type in (CREATE, UPDATE, DELETE):\n        return\n    print('Preparing response to CloudFormation... \\n')\n    responseUrl = event['ResponseURL']\n    responseBody = {\n        'Status': responseStatus,\n        'Reason': reason or f'See the details in CloudWatch Log Stream: {context.log_stream_name}',\n        'PhysicalResourceId': physicalResourceId or context.log_stream_name,\n        'StackId': event['StackId'],\n        'RequestId': event['RequestId'],\n        'LogicalResourceId': event['LogicalResourceId'],\n        'NoEcho': noEcho,\n        'Data': responseData\n    }\n    print('Response body:', responseBody, '\\n')\n    json_responseBody = json.dumps(responseBody)\n    headers = {\n        'content-type': '',\n        'content-length': str(len(json_responseBody))\n    }\n    try:\n        print('Sending response to CloudFormation via http request... \\n')\n        response = http.request(\n            'PUT', responseUrl, headers=headers, body=json_responseBody, retries=5)\n        print('Status code:', response.status, '\\n')\n    # If this actually happens, the stack could get stuck for an hour\n    # waiting for a response from this custom resource.\n    # There is a manual way to send a response using curl\n    except Exception as err:\n        print('Send failed executing http.request:')\n        print(err, '\\n')\n        raise err\ndef lambda_handler(event, context):\n    request_type = event.get('RequestType')\n    # In case of Remediate, ResourceProperties only has BucketName and PatchBaselineIds\n    resource_properties = event['ResourceProperties']\n    bucket_name = resource_properties['BucketName']\n    patch_baseline_ids = [baseline.get('value') for baseline in json.loads(resource_properties['PatchBaselines']).values()]\n    access_log_bucket_name = resource_properties.get('AccessLogBucketName')\n    print('Event:', event, '\\n')\n    try:\n        if request_type == CREATE:\n            create_bucket(bucket_name)\n            put_bucket_versioning(bucket_name)\n            put_bucket_encryption(bucket_name)\n            put_public_access_block(bucket_name)\n            put_bucket_lifecycle_configuration(bucket_name)\n            put_bucket_policy(bucket_name, resource_properties)\n            put_bucket_logging(bucket_name, access_log_bucket_name)\n            place_baselines_into_bucket(\n                bucket_name, get_patch_baselines(patch_baseline_ids, request_type))\n            send(event, context, SUCCESS, physicalResourceId=bucket_name)\n        elif request_type == UPDATE:\n            # We are making an assumption that Update event will never cause creation of another bucket.\n            # Bucket name is dynamically constructed using AccountId and QSConfigId\n            put_bucket_policy(bucket_name, resource_properties)\n            place_baselines_into_bucket(\n                bucket_name, get_patch_baselines(patch_baseline_ids, request_type))\n            send(event, context, SUCCESS, physicalResourceId=bucket_name)\n        elif request_type == DELETE:\n            empty_and_delete_bucket(bucket_name)\n            send(event, context, SUCCESS, physicalResourceId=bucket_name)\n        elif request_type == REMEDIATE:\n            print('Starting remediation... \\n')\n            place_baselines_into_bucket(\n                bucket_name, get_patch_baselines(patch_baseline_ids, request_type))\n            print('Remediation completed \\n')\n        else:\n            print('Unexpected request type received:', request_type)\n            raise ValueError(\n                'A valid RequestType is Create, Update, Delete, or Remediate')\n        return SUCCESS\n    except Exception as err:\n        print(err, '\\n')\n        print('You can review the log for the Lambda function for details \\n')\n        send(event, context, FAILED, reason=str(err), physicalResourceId=bucket_name)\n        raise err  # To send signal to Automation Document of failure\n"
      Runtime: python3.9
      Handler: index.lambda_handler
      Environment:
        Variables:
          REGION: !Sub "${AWS::Region}"
      MemorySize: 128
      Role: !GetAtt
        - BaselineOverridesLambdaRole
        - Arn
      Timeout: 300
    Condition: DeployManagementResources
  BaselineOverridesLambdaLogGroup:
    Type: 'AWS::Logs::LogGroup'
    Properties:
      LogGroupName: !Join
        - '-'
        - - /aws/lambda/baseline-overrides
          - !Select
            - 3
            - !Split
              - '-'
              - !Select
                - 2
                - !Split
                  - /
                  - !Ref 'AWS::StackId'
          - !Ref QSConfigurationId
      RetentionInDays: 365
    DeletionPolicy: Delete
    Condition: DeployManagementResources
  BaselineOverridesLambdaRole:
    Type: 'AWS::IAM::Role'
    Properties:
      RoleName: !Sub 'AWS-QuickSetup-BaselineOverrides-LambdaRole-${AWS::Region}-${QSConfigurationId}'
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      Policies:
        - PolicyName: !Sub 'AWS-QuickSetup-BaselineOverrides-LambdaPolicy-${QSConfigurationId}'
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Sid: AllowS3Actions
                Effect: Allow
                Action:
                  - 's3:CreateBucket'
                  - 's3:PutBucketVersioning'
                  - 's3:PutBucketOwnershipControls'
                  - 's3:PutBucketPublicAccessBlock'
                  - 's3:PutEncryptionConfiguration'
                  - 's3:GetObject'
                  - 's3:PutBucketPolicy'
                  - 's3:GetObjectVersion'
                  - 's3:PutObject'
                  - 's3:DeleteObject'
                  - 's3:ListBucketVersions'
                  - 's3:DeleteObjectVersion'
                  - 's3:DeleteBucket'
                  - 's3:PutLifecycleConfiguration'
                  - 's3:ListBucket'
                  - 's3:PutBucketLogging'
                Resource:
                  - !Sub >-
                    arn:${AWS::Partition}:s3:::aws-quicksetup-patchpolicy-${AWS::AccountId}-${QSConfigurationId}-${AWS::Region}/*
                  - !Sub >-
                    arn:${AWS::Partition}:s3:::aws-quicksetup-patchpolicy-${AWS::AccountId}-${QSConfigurationId}-${AWS::Region}
              - Sid: AllowLogging
                Effect: Allow
                Action:
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource:
                  - !Join
                    - ''
                    - - !Sub >-
                        arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/baseline-overrides-
                      - !Select
                        - 3
                        - !Split
                          - '-'
                          - !Select
                            - 2
                            - !Split
                              - /
                              - !Ref 'AWS::StackId'
                      - '-'
                      - !Ref QSConfigurationId
                      - ':*'
              - Sid: AllowSSMActions
                Action:
                  - 'ssm:GetPatchBaseline'
                Effect: Allow
                Resource: '*'
    Condition: DeployManagementResources
  BaselineOverridesLambdaTrigger:
    Type: 'Custom::S3Object'
    Properties:
      ServiceToken: !GetAtt
        - BaselineOverridesLambdaFunction
        - Arn
      AccountId: !Sub ${AWS::AccountId}
      QSConfigId: !Ref QSConfigurationId
      BucketName: !Sub 'aws-quicksetup-patchpolicy-${AWS::AccountId}-${QSConfigurationId}-${AWS::Region}'
      AccessLogBucketName: !Ref BaselineOverridesAccessLogBucket
      Partition: !Ref 'AWS::Partition'
      TargetEntities: !Ref TargetEntities
      OrgUnits: !Ref OUs
      PrincipalOrgId: !Ref OrgId
      PatchBaselines: !Ref SelectedPatchBaselines
    Condition: DeployManagementResources
  BaselineOverridesStateManagerAssociation:
    Type: 'AWS::SSM::Association'
    Properties:
      AssociationName: !Sub 'AWS-QuickSetup-PatchPolicy-BaselineRemediation-${QSConfigurationId}'
      Name: !Ref BaselineOverridesRemediationAutomationDocument
      ApplyOnlyAtCronInterval: true
      ScheduleExpression: cron(0 0/1 * * ? *)
    Condition: DeployManagementResources
  BaselineOverridesRemediationAutomationDocument:
    Type: 'AWS::SSM::Document'
    Properties:
      Name: !Sub 'QuickSetup-Remediation-AutomationDocument-${QSConfigurationId}'
      DocumentType: Automation
      UpdateMethod: NewVersion
      Content:
        description: >-
          This Document is to trigger the Lambda function to perform remediation only.
        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        parameters:
          AutomationAssumeRole:
            type: String
            default: !GetAtt
              - BaselineOverridesRemediationAutomationRole
              - Arn
          LambdaFunctionArn:
            type: String
            default: !GetAtt
              - BaselineOverridesLambdaFunction
              - Arn
          BucketName:
            type: String
            default: !Sub 'aws-quicksetup-patchpolicy-${AWS::AccountId}-${QSConfigurationId}-${AWS::Region}'
          PatchBaselines:
            type: String
            default: !Ref SelectedPatchBaselines
        mainSteps:
          - name: invokeBaselineOverridesLambdaFunction
            action: 'aws:invokeLambdaFunction'
            timeoutSeconds: 300
            inputs:
              FunctionName: '{{ LambdaFunctionArn }}'
              InputPayload:
                RequestType: Remediate
                ResourceProperties:
                  BucketName: '{{ BucketName }}'
                  PatchBaselines: '{{ PatchBaselines }}'
    Condition: DeployManagementResources
  BaselineOverridesRemediationAutomationRole:
    Type: 'AWS::IAM::Role'
    Properties:
      RoleName: !Sub 'AWS-QuickSetup-Remediation-AutomationRole-${AWS::Region}-${QSConfigurationId}'
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - ssm.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      Policies:
        - PolicyName: !Sub 'AWS-QuickSetup-Remediation-AutomationPolicy-${QSConfigurationId}'
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - 'lambda:InvokeFunction'
                Resource: !GetAtt
                  - BaselineOverridesLambdaFunction
                  - Arn
    Condition: DeployManagementResources
  RoleForAutomation:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - ssm.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      Policies:
        - PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - 'iam:AttachRolePolicy'
                Resource:
                  - !If
                    - PolicyAttachAllowed
                    - '*'
                    - !Sub >-
                      arn:${AWS::Partition}:iam::${AWS::AccountId}:role/AmazonSSMRoleForInstancesQuickSetup
                Condition:
                  ArnEquals:
                    'iam:PolicyARN':
                      - !Sub >-
                        arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore
                      - !Sub >-
                        arn:${AWS::Partition}:iam::${AWS::AccountId}:policy/ssm/quicksetup/patchpolicy/aws-quicksetup-patchpolicy-baselineoverrides-s3
              - Effect: Allow
                Action:
                  - 'iam:TagRole'
                Resource:
                  - !If
                    - PolicyAttachAllowed
                    - '*'
                    - !Sub >-
                      arn:${AWS::Partition}:iam::${AWS::AccountId}:role/AmazonSSMRoleForInstancesQuickSetup
                Condition:
                  'ForAllValues:StringEquals':
                    'aws:TagKeys': !Sub 'QSConfigId-${QSConfigurationId}'
              - Effect: Deny
                Action:
                  - 'iam:TagRole'
                  - 'iam:AttachRolePolicy'
                Resource: !Sub >-
                  arn:${AWS::Partition}:iam::${AWS::AccountId}:role/AWS-QuickSetup-AutomationRole-*
              - Effect: Allow
                Action:
                  - 'iam:CreatePolicy'
                Resource: !Sub >-
                  arn:${AWS::Partition}:iam::${AWS::AccountId}:policy/ssm/quicksetup/patchpolicy/aws-quicksetup-patchpolicy-baselineoverrides-s3
              - Effect: Allow
                Action:
                  - 'iam:PassRole'
                Resource: !Sub >-
                  arn:${AWS::Partition}:iam::${AWS::AccountId}:role/AmazonSSMRoleForInstancesQuickSetup
                Condition:
                  StringEquals:
                    'iam:PassedToService':
                      - ec2.amazonaws.com
              - Effect: Allow
                Action:
                  - 'iam:PassRole'
                Resource: !Sub >-
                  arn:${AWS::Partition}:iam::${AWS::AccountId}:role/AmazonSSMRoleForInstancesQuickSetup
                Condition:
                  StringEquals:
                    'iam:PassedToService':
                      - ssm.amazonaws.com
              - Effect: Allow
                Action:
                  - 'ec2:AssociateIamInstanceProfile'
                Resource: '*'
                Condition:
                  StringEquals:
                    'ec2:NewInstanceProfile': !Sub >-
                      arn:${AWS::Partition}:iam::${AWS::AccountId}:instance-profile/AmazonSSMRoleForInstancesQuickSetup
              - Effect: Allow
                Action:
                  - 'iam:AddRoleToInstanceProfile'
                Resource: !Sub >-
                  arn:${AWS::Partition}:iam::${AWS::AccountId}:instance-profile/AmazonSSMRoleForInstancesQuickSetup
              - Effect: Allow
                Action:
                  - 'iam:CreateRole'
                  - 'iam:GetRole'
                Resource: !Sub >-
                  arn:${AWS::Partition}:iam::${AWS::AccountId}:role/AmazonSSMRoleForInstancesQuickSetup
              - Effect: Allow
                Action:
                  - 'iam:CreateInstanceProfile'
                Resource: !Sub >-
                  arn:${AWS::Partition}:iam::${AWS::AccountId}:instance-profile/AmazonSSMRoleForInstancesQuickSetup
              - Effect: Allow
                Action:
                  - 'ec2:DescribeIamInstanceProfileAssociations'
                  - 'ec2:DescribeInstances'
                  - 'iam:GetInstanceProfile'
                  - 'iam:ListInstanceProfilesForRole'
                  - 'ssm:DescribeInstanceInformation'
                  - 'ssm:UpdateManagedInstanceRole'
                  - 'ssm:GetAutomationExecution'
                  - 'ssm:StartAutomationExecution'
                Resource: '*'
              - Effect: Allow
                Action:
                  - 'iam:PassRole'
                Resource: !Sub >-
                  arn:${AWS::Partition}:iam::${AWS::AccountId}:role/AWS-QuickSetup-AutomationRole-${AWS::Region}-${QSConfigurationId}
                Condition:
                  StringEquals:
                    'iam:PassedToService':
                      - ssm.amazonaws.com
          PolicyName: !Sub >-
            AWS-QuickSetup-AutomationPolicy-IAM-${AWS::Region}-${QSConfigurationId}
        - PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - 'ssm:RemoveTagsFromResource'
                  - 'ssm:GetInventory'
                  - 'ssm:AddTagsToResource'
                Resource: '*'
          PolicyName: !Sub >-
            AWS-QuickSetup-AutomationPolicy-NameTagRemediation-${AWS::Region}-${QSConfigurationId}
        - PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - 'ec2:CreateTags'
                  - 'ec2:DeleteTags'
                Resource: '*'
                Condition:
                  'ForAllValues:StringEquals':
                    'aws:TagKeys': !Sub 'QSConfigName-${QSConfigurationId}'
          PolicyName: !Sub >-
            AWS-QuickSetup-AutomationPolicy-AddRemoveNameTag-${AWS::Region}-${QSConfigurationId}
      RoleName: !Sub 'AWS-QuickSetup-AutomationRole-${AWS::Region}-${QSConfigurationId}'
    DependsOn:
      - CreateAndAttachIAMToEc2InstanceDocument
      - AddRemoveNameTagAutomationDocument
      - NameTagRemediationDocument
  EnableExplorerRoleForPatchPolicy:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - ssm.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      Policies:
        - PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - 'iam:ListRoles'
                  - 'config:DescribeConfigurationRecorders'
                  - 'compute-optimizer:GetEnrollmentStatus'
                  - 'support:DescribeTrustedAdvisorChecks'
                Resource: '*'
              - Effect: Allow
                Action:
                  - 'ssm:UpdateServiceSetting'
                  - 'ssm:GetServiceSetting'
                Resource:
                  - !Sub >-
                    arn:${AWS::Partition}:ssm:*:*:servicesetting/ssm/opsitem/ssm-patchmanager
                  - !Sub 'arn:${AWS::Partition}:ssm:*:*:servicesetting/ssm/opsitem/EC2'
                  - !Sub >-
                    arn:${AWS::Partition}:ssm:*:*:servicesetting/ssm/opsdata/ExplorerOnboarded
                  - !Sub >-
                    arn:${AWS::Partition}:ssm:*:*:servicesetting/ssm/opsdata/Association
                  - !Sub >-
                    arn:${AWS::Partition}:ssm:*:*:servicesetting/ssm/opsdata/ComputeOptimizer
                  - !Sub >-
                    arn:${AWS::Partition}:ssm:*:*:servicesetting/ssm/opsdata/ConfigCompliance
                  - !Sub >-
                    arn:${AWS::Partition}:ssm:*:*:servicesetting/ssm/opsdata/OpsData-TrustedAdvisor
                  - !Sub >-
                    arn:${AWS::Partition}:ssm:*:*:servicesetting/ssm/opsdata/SupportCenterCase
              - Effect: Allow
                Action:
                  - 'iam:CreateServiceLinkedRole'
                Resource: !Sub >-
                  arn:${AWS::Partition}:iam::*:role/aws-service-role/ssm.${AWS::URLSuffix}/AWSServiceRoleForAmazonSSM
                Condition:
                  StringEquals:
                    'iam:AWSServiceName': ssm.amazonaws.com
          PolicyName: !Sub 'SSMQuickSetupEnableExplorerInlinePolicy'
      RoleName: !Sub 'AWS-QuickSetup-EnableExplorer-${AWS::Region}-${QSConfigurationId}'
  QuickSetupEnableExplorerAssociation:
    Type: 'AWS::SSM::Association'
    Properties:
      Name: AWS-EnableExplorer
      AssociationName: !Sub 'AWS-QuickSetup-PatchPolicy-EnableExplorer-${QSConfigurationId}'
      Parameters:
        AutomationAssumeRole:
          - !GetAtt
            - EnableExplorerRoleForPatchPolicy
            - Arn
  NameTagDeleteLambda:
    Type: 'AWS::Lambda::Function'
    Properties:
      Code:
        ZipFile: "# Copyright 2022 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n\n# This handler responds to a Cloud Formation Stack 'DELETE' notification. \n# It is responsible for detaching all name tags from target nodes, including\n# nodes that are no longer a target of the Quick Setup Configuration but for which\n# drift has not yet been remediated.\nfrom asyncore import poll\nfrom botocore.exceptions import ClientError\nimport boto3\nimport json\nfrom urllib.request import build_opener, HTTPHandler, Request\nimport os\nimport time\n\n# ENVIRONMENT VARIABLES\nregion = os.environ['REGION']\n\n# CONSTANTS\nMINUTES_FOR_POLLING_COMPLETION = 600 # 10 hrs max.\nASSOCIATION_NON_TERMINAL_STATUSES = [\"Pending\", \"InProgress\"]\nDESCRIBE_ASSOCIATION_KEYS = [\"AssociationId\",\"Parameters\",\"DocumentVersion\",\"ScheduleExpression\",\\\n    \"OutputLocation\",\"Name\",\"Targets\",\"AssociationName\",\"AssociationVersion\",\"AutomationTargetParameterName\",\\\n    \"MaxErrors\",\"MaxConcurrency\",\"ComplianceSeverity\",\"SyncCompliance\",\"ApplyOnlyAtCronInterval\",\"CalendarNames\",\\\n    \"TargetLocations\"]\n\n# CLIENTS\nclient = boto3.client('ssm', region_name= region)  \n\ndef build_request(event,status, message):\n    try:\n        stack_id = check_for_key(event, 'StackId')\n        request_id = check_for_key(event, 'RequestId')\n        logical_resource_id = check_for_key(event, 'LogicalResourceId')\n\n        body = json.dumps({        \n            'Status': status,        \n            'Reason': message,        \n            'StackId': stack_id,\n            'RequestId': request_id,\n            'LogicalResourceId': logical_resource_id,\n            'PhysicalResourceId': 'associationId'})\n     \n        request = Request(check_for_key(event, 'ResponseURL'), data=body.encode('utf-8'))\n        request.add_header('Content-Type', '')\n        request.add_header('Content-Length', len(body.encode('utf-8')))\n        request.get_method = lambda: 'PUT'\n        return request\n    except Exception as ex:\n        raise Exception(\"An Exception occurred while building a response for Cloud Formation. %s\"%(str(ex)))\n\ndef poll_for_association_completion(event, association_ids):\n    for id in association_ids:\n        counter = 0\n        while True:\n            print(\"Polling for Association completion: %s\"%(id))\n            response = client.describe_association_executions(AssociationId=id)\n            print(\"DescribeAssociationExecution result: %s\"%(str(response)))\n            ## check status, exit if good\n            executions = response[\"AssociationExecutions\"]\n            if (len(executions) < 1):\n                msg = \"Association %s has never been executed. Something went wrong. \"%(id)\n                send_response(event, \"FAILED\", msg)\n                return False\n            else:\n                status = executions[0][\"Status\"]\n                print(\"Found status of %s for latest execution of %s\"%(status, id))\n                # Association Execution History is always reported in descending order. \n                if (status in ASSOCIATION_NON_TERMINAL_STATUSES):\n                    print(\"Association %s is %s . Waiting 5 seconds. \"%(id, executions[0][\"Status\"]))\n                    time.sleep(5)\n                    counter +=1\n\n                    if counter == MINUTES_FOR_POLLING_COMPLETION:\n                        msg = \"Association has not finished in the required time. Exiting.\"\n                        send_response(event, \"FAILED\", msg)\n                        return False\n                else:\n                    # if the status is not success, fail the Lambda. \n                    if (status.lower() != \"success\"):\n                        msg = \"Association %s returned a non-success status of %s.\"%(id, status)\n                        send_response(event, \"FAILED\", msg)\n                        return False\n                    else:\n                        print(\"Association %s completed successfully.\"%(id))\n                        return True\n\ndef build_opener_and_open(request):\n    opener = build_opener(HTTPHandler)\n    response = opener.open(request) \n    return response\n\ndef send_response(event, status, message, count = 0):\n    try:\n        request = build_request(event, status, message)\n        response = build_opener_and_open(request)\n        # This snippet is the reason behind not using the cfnresponse python module\n        # found here: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/cfn-lambda-function-code-cfnresponsemodule.html\n        # The cfnresponse python module simply print's an http status code error and succeeds. \n        # The desired behavior is for the Lambda to fail if the response code is not 200.\n        # technically, this response status should be a string but the urllib library doesn't say\n        # if it is translated to a string or not.\n        if str(response.status) != \"200\":\n            raise Exception(\"Received a failed response from Cloud Formation: %s\"%(str(response.status)))\n    except Exception as ex:\n        print(\"An Exception occured while sending a response to Cloud Formation. \")\n        if count < 3:\n            count +=1\n            send_response(event, status, message, count)\n        else:\n            raise Exception(\"Retries failed. Failing Lambda execution.\")\n\n\ndef check_for_key(hash, key):\n    if not key in hash:\n        raise Exception(\"The required key %s is not present in %s. Failing.\"%(key, str(hash)))\n    else:\n        # return the value\n        return hash[key]\n\ndef update_association(event, association_id):\n\n    print(\"Describing association %s for update command.\"%(association_id))\n    response = client.describe_association(AssociationId=association_id)\n    print(response)\n\n    association = response['AssociationDescription']\n    print(\"Using Association Overview %s: \"%(str(association)))\n    print(\"Stripping described association of keys that cannot be used in update command.\")\n    keys_to_pop = []\n    [keys_to_pop.append(key) if key not in DESCRIBE_ASSOCIATION_KEYS else print(key) for key in association]\n    [association.pop(key) for key in keys_to_pop]\n\n    # Postfix name with -delete for easy identification. \n    association[\"AssociationName\"] = association[\"AssociationName\"] + \"-DELETE\"\n\n    # TAG DOCUMENT\n    if \"TagAction\" in association[\"Parameters\"]:\n        association[\"AutomationTargetParameterName\"] = \"InstanceId\"\n        association[\"Targets\"] = association[\"Targets\"]\n        association[\"Parameters\"][\"TagAction\"] = [\"Remove\"]\n    else: \n        # REMEDIATION DOCUMENT\n        # Remediation document uses the NoOp Automation target tag which State Manager does not\n        # comprehend as a parameter and only adds if the following parameters are not present.\n        if \"Targets\" in association: \n            association.pop(\"Targets\")\n\n    print(\"Attempting to update association %s\"%(association))\n    response = client.update_association(**association)\n    print(\"UpdateResponse: %s\"%(str(response)))\n\ndef handler(event, context):      \n    try:\n        print(\"Received event %s\"%(str(event)))\n    \n        request = None\n        request = check_for_key(event, 'RequestType')\n\n        if (request == None or request.lower() != 'delete'):\n            msg = \"Received a %s request. Tag Detach Machine only handles CF Stack 'Delete' events. Succeeding.\"%(str(request))\n            send_response(event, \"SUCCESS\", msg)\n            return\n\n        resource_properties = check_for_key(event, \"ResourceProperties\")\n\n        tag_association_id =check_for_key(resource_properties, 'TagAssociationId')\n        remediation_association_id = check_for_key(resource_properties, 'RemediationAssociationId')\n\n        # Now update the associations to have the names postfixed with DELETE and trigger a name tag delete.\n        update_association(event, tag_association_id)\n        update_association(event, remediation_association_id)\n\n        # Giving Association time to update and trigger new executions.\n        print(\"Sleeping to give Association time to update: %s\"%(time.ctime()))\n        time.sleep(15)\n        print(\"Done sleeping: %s\"%(time.ctime()))\n\n        #Now poll for the associations to finish\n        success = poll_for_association_completion(event, [tag_association_id, remediation_association_id])       \n\n        if success == True:\n            # Once the associations have finished.\n            send_response(event, \"SUCCESS\", \"Association's successfully completed. Exiting Lambda.\")\n        else:\n            msg = \"Name tags failed to delete. Retaining resources so customer can trigger a delete after the fact.\"\n            send_response(event, \"FAILED\", \"%s:\"%(msg))\n\n    except Exception as e:\n        send_response(event, \"FAILED\", \"%s:\"%(str(e)))\n        raise(e)\n"
      Timeout: 900
      Description: >-
        Lambda for handling CF 'Delete' events to remove the name tags from resources.
      Runtime: python3.9
      Role: !GetAtt
        - RoleForLambdaNameTagDelete
        - Arn
      FunctionName: !Join
        - '-'
        - - !Sub 'delete-name-tags-${AWS::Region}'
          - !Select
            - 3
            - !Split
              - '-'
              - !Select
                - 2
                - !Split
                  - /
                  - !Ref 'AWS::StackId'
          - !Ref QSConfigurationId
      Handler: index.handler
      Environment:
        Variables:
          REGION: !Ref 'AWS::Region'
    DependsOn:
      - RoleForLambdaNameTagDelete
  RoleForLambdaNameTagDelete:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      Policies:
        - PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - 'ssm:DescribeAssociationExecutions'
                  - 'ssm:UpdateAssociation'
                  - 'ssm:DescribeAssociation'
                Resource:
                  - '*'
          PolicyName: !Sub >-
            AWS-QuickSetup-LambdaPolicy-NameTagDelete-${AWS::Region}-${QSConfigurationId}
        - PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - 'iam:PassRole'
                Resource:
                  - !Sub >-
                    arn:${AWS::Partition}:iam::${AWS::AccountId}:role/AWS-QuickSetup-AutomationRole-${AWS::Region}-${QSConfigurationId}
          PolicyName: !Sub >-
            AWS-QuickSetup-LambdaPolicy-PassRole-${AWS::Region}-${QSConfigurationId}
      ManagedPolicyArns:
        - !Sub >-
          arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      RoleName: !Sub >-
        AWS-QuickSetup-PatchPolicy-RoleForLambda-NT-${AWS::Region}-${QSConfigurationId}
  NameTagDeleteMachine:
    Type: 'Custom::NameTagDeleteMachine'
    Version: '1.0'
    Properties:
      ServiceToken: !GetAtt
        - NameTagDeleteLambda
        - Arn
      AutomationAssumeRole: !GetAtt
        - RoleForAutomation
        - Arn
      RemediationAssociationId: !GetAtt SystemAssociationForNameTagRemediation.AssociationId
      TagAssociationId: !GetAtt SystemAssociationForAddRemoveNameTag.AssociationId
    DependsOn:
      - RoleForAutomation
      - NameTagDeleteLambda
      - RoleForLambdaNameTagDelete
      - SystemAssociationForAddRemoveNameTag
      - SystemAssociationForNameTagRemediation
  NameTagDeleteLambdaLogGroup:
    Type: 'AWS::Logs::LogGroup'
    Properties:
      LogGroupName: !Join
        - '-'
        - - !Sub '/aws/lambda/delete-name-tags-${AWS::Region}'
          - !Select
            - 3
            - !Split
              - '-'
              - !Select
                - 2
                - !Split
                  - /
                  - !Ref 'AWS::StackId'
          - !Ref QSConfigurationId
      RetentionInDays: 365
    DeletionPolicy: Delete
    DependsOn: NameTagDeleteLambda
  SystemAssociationForScanningPatches:
    Type: 'AWS::SSM::Association'
    Properties:
      Name: AWS-RunPatchBaseline
      AssociationName: !Sub 'AWS-QuickSetup-PatchPolicy-ScanForPatches-${QSType}-${QSConfigurationId}'
      Parameters:
        Operation:
          - Scan
        BaselineOverride:
          - !Sub >-
            s3://aws-quicksetup-patchpolicy-${AWS::AccountId}-${QSConfigurationId}-${AWS::Region}/baseline_overrides.json
        RebootOption:
          - !Ref RebootOption
      ScheduleExpression: !Ref ConfigurationOptionsScanValue
      ApplyOnlyAtCronInterval: !Ref ConfigurationOptionsScanNextInterval
      SyncCompliance: MANUAL
      Targets: !If
        - IsTagKeyAndValueTargeted
        - - Key: !Sub 'tag:${TargetTagKey}'
            Values:
              - !Ref TargetTagValue
        - !If
          - IsTagKeyOnlyTargeted
          - - Key: tag-key
              Values:
                - !Ref TargetTagKey
          - !If
            - IsResourceGroupTargeted
            - - Key: 'resource-groups:Name'
                Values:
                  - !Ref ResourceGroupName
            - !If
              - TargetAll
              - - Key: InstanceIds
                  Values:
                    - '*'
              - - Key: InstanceIds
                  Values: !Split
                    - ','
                    - !Ref TargetInstances
      MaxConcurrency: !Ref RateControlConcurrency
      MaxErrors: !Ref RateControlErrorThreshold
      OutputLocation: !If
        - EnabledOutputBucketWithPrefix
        - S3Location:
            OutputS3BucketName: !Ref OutputS3BucketName
            OutputS3KeyPrefix: !Ref OutputS3KeyPrefix
            OutputS3Region: !Ref OutputBucketRegion
        - !If
          - EnabledOutputBucketWithoutPrefix
          - S3Location:
              OutputS3BucketName: !Ref OutputS3BucketName
              OutputS3Region: !Ref OutputBucketRegion
          - !Ref 'AWS::NoValue'
  SystemAssociationForInstallingPatches:
    Type: 'AWS::SSM::Association'
    Properties:
      Name: AWS-RunPatchBaseline
      AssociationName: !Sub 'AWS-QuickSetup-PatchPolicy-InstallPatches-${QSType}-${QSConfigurationId}'
      Parameters:
        Operation:
          - Install
        BaselineOverride:
          - !Sub >-
            s3://aws-quicksetup-patchpolicy-${AWS::AccountId}-${QSConfigurationId}-${AWS::Region}/baseline_overrides.json
        RebootOption:
          - !Ref RebootOption
      ApplyOnlyAtCronInterval: !Ref ConfigurationOptionsInstallNextInterval
      ScheduleExpression: !Ref ConfigurationOptionsInstallValue
      SyncCompliance: MANUAL
      Targets: !If
        - IsTagKeyAndValueTargeted
        - - Key: !Sub 'tag:${TargetTagKey}'
            Values:
              - !Ref TargetTagValue
        - !If
          - IsTagKeyOnlyTargeted
          - - Key: tag-key
              Values:
                - !Ref TargetTagKey
          - !If
            - IsResourceGroupTargeted
            - - Key: 'resource-groups:Name'
                Values:
                  - !Ref ResourceGroupName
            - !If
              - TargetAll
              - - Key: InstanceIds
                  Values:
                    - '*'
              - - Key: InstanceIds
                  Values: !Split
                    - ','
                    - !Ref TargetInstances
      MaxConcurrency: !Ref RateControlConcurrency
      MaxErrors: !Ref RateControlErrorThreshold
      OutputLocation: !If
        - EnabledOutputBucketWithPrefix
        - S3Location:
            OutputS3BucketName: !Ref OutputS3BucketName
            OutputS3KeyPrefix: !Ref OutputS3KeyPrefix
            OutputS3Region: !Ref OutputBucketRegion
        - !If
          - EnabledOutputBucketWithoutPrefix
          - S3Location:
              OutputS3BucketName: !Ref OutputS3BucketName
              OutputS3Region: !Ref OutputBucketRegion
          - !Ref 'AWS::NoValue'
    Condition: CreateInstallInstancesAssociation
  SystemAssociationForEc2IamManagement:
    Type: 'AWS::SSM::Association'
    Properties:
      ScheduleExpression: rate(1 day)
      Name: !Ref CreateAndAttachIAMToEc2InstanceDocument
      AssociationName: !Sub 'AWS-QuickSetup-PatchPolicy-AttachIAMToEc2Instance-${QSConfigurationId}'
      Parameters:
        AutomationAssumeRole:
          - !GetAtt
            - RoleForAutomation
            - Arn
        IsPolicyAttachAllowed:
          - !Ref IsPolicyAttachAllowed
        QSConfigurationId:
          - !Ref QSConfigurationId
        AwsAccountId:
          - !Ref 'AWS::AccountId'
      AutomationTargetParameterName: InstanceId
      Targets: !If
        - IsTagKeyAndValueTargeted
        - - Key: !Sub 'tag:${TargetTagKey}'
            Values:
              - !Ref TargetTagValue
        - !If
          - IsTagKeyOnlyTargeted
          - - Key: tag-key
              Values:
                - !Ref TargetTagKey
          - !If
            - IsResourceGroupTargeted
            - - Key: ResourceGroup
                Values:
                  - !Ref ResourceGroupName
            - !If
              - TargetAll
              - - Key: InstanceIds
                  Values:
                    - '*'
              - - Key: ParameterValues
                  Values: !Split
                    - ','
                    - !Ref TargetInstances
    DependsOn:
      - CreateAndAttachIAMToEc2InstanceDocument
      - RoleForAutomation
  SystemAssociationForAddRemoveNameTag:
    Type: 'AWS::SSM::Association'
    Properties:
      ScheduleExpression: rate(1 day)
      Name: !Ref AddRemoveNameTagAutomationDocument
      AssociationName: !Sub 'AWS-QuickSetup-PatchPolicy-AddRemoveNameTag-${QSConfigurationId}'
      Parameters:
        AutomationAssumeRole:
          - !GetAtt
            - RoleForAutomation
            - Arn
        QSConfigurationName:
          - !Ref QSConfigurationName
        QSConfigurationId:
          - !Ref QSConfigurationId
        TagAction:
          - Add
      AutomationTargetParameterName: InstanceId
      Targets: !If
        - IsTagKeyAndValueTargeted
        - - Key: !Sub 'tag:${TargetTagKey}'
            Values:
              - !Ref TargetTagValue
        - !If
          - IsTagKeyOnlyTargeted
          - - Key: tag-key
              Values:
                - !Ref TargetTagKey
          - !If
            - IsResourceGroupTargeted
            - - Key: ResourceGroup
                Values:
                  - !Ref ResourceGroupName
            - !If
              - TargetAll
              - - Key: InstanceIds
                  Values:
                    - '*'
              - - Key: ParameterValues
                  Values: !Split
                    - ','
                    - !Ref TargetInstances
    DependsOn:
      - AddRemoveNameTagAutomationDocument
      - RoleForAutomation
  SystemAssociationForHybridIamManagement:
    Type: 'AWS::SSM::Association'
    Properties:
      ScheduleExpression: rate(1 day)
      Name: !Ref CreateAndAttachIAMToHybridInstanceDocument
      AssociationName: !Sub >-
        AWS-QuickSetup-PatchPolicy-AttachIAMToHybridInstance-${QSConfigurationId}
      Parameters:
        AutomationAssumeRole:
          - !GetAtt
            - RoleForAutomation
            - Arn
        IsPolicyAttachAllowed:
          - !Ref IsPolicyAttachAllowed
        QSConfigurationId:
          - !Ref QSConfigurationId
        AwsAccountId:
          - !Ref 'AWS::AccountId'
        Region:
          - !Ref 'AWS::Region'
      AutomationTargetParameterName: InstanceId
      Targets: !If
        - IsTagKeyAndValueTargeted
        - - Key: !Sub 'tag:${TargetTagKey}'
            Values:
              - !Ref TargetTagValue
        - !If
          - IsTagKeyOnlyTargeted
          - - Key: tag-key
              Values:
                - !Ref TargetTagKey
          - !If
            - IsResourceGroupTargeted
            - - Key: ResourceGroup
                Values:
                  - !Ref ResourceGroupName
            - !If
              - TargetAll
              - - Key: InstanceIds
                  Values:
                    - '*'
              - - Key: ParameterValues
                  Values: !Split
                    - ','
                    - !Ref TargetInstances
    DependsOn: CreateAndAttachIAMToHybridInstanceDocument
  SystemAssociationForNameTagRemediation:
    Type: 'AWS::SSM::Association'
    Properties:
      ScheduleExpression: rate(1 day)
      Name: !Ref NameTagRemediationDocument
      AssociationName: !Sub 'AWS-QuickSetup-PatchPolicy-NameTagRemediation-${QSConfigurationId}'
      Parameters:
        AutomationAssumeRole:
          - !GetAtt
            - RoleForAutomation
            - Arn
        TargetType:
          - !Ref TargetType
        NameKey:
          - !Sub 'QSConfigName-${QSConfigurationId}'
        NameValue:
          - !Ref QSConfigurationName
        TargetValues:
          - !If
            - IsTagKeyAndValueTargeted
            - !Join
              - ''
              - - '{"Key":"'
                - !Sub '${TargetTagKey}'
                - '",'
                - '"Value":"'
                - !Ref TargetTagValue
                - '"}'
            - !If
              - IsTagKeyOnlyTargeted
              - !Join
                - ''
                - - '{"Key":"'
                  - !Ref TargetTagKey
                  - '"}'
              - !If
                - IsResourceGroupTargeted
                - !Join
                  - ''
                  - - '{"Key":"'
                    - !Ref ResourceGroupName
                    - '"}'
                - !If
                  - TargetAll
                  - '{"Key":"*"}'
                  - !Join
                    - ''
                    - - '{"Key":"'
                      - !Ref TargetInstances
                      - '"}'
        Region:
          - !Sub '${AWS::Region}'
    DependsOn:
      - NameTagRemediationDocument
      - RoleForAutomation
  CreateAndAttachIAMToEc2InstanceDocument:
    Type: 'AWS::SSM::Document'
    Properties:
      Content:
        description: >-
          Composite document for Quick Setup Managing Instances association. This document ensures IAM role for instance profile is created in account with all required policies
        schemaVersion: '0.3'
        assumeRole: '{{AutomationAssumeRole}}'
        parameters:
          AutomationAssumeRole:
            type: String
          InstanceId:
            type: String
          IsPolicyAttachAllowed:
            type: String
          AwsAccountId:
            type: String
          QSConfigurationId:
            type: String
        mainSteps:
          - name: branchOnInstanceType
            action: 'aws:branch'
            inputs:
              Choices:
                - NextStep: getExistingRoleName
                  Variable: '{{InstanceId}}'
                  StartsWith: i-
            isEnd: true
          - name: getExistingRoleName
            action: 'aws:executeScript'
            inputs:
              Runtime: python3.8
              Handler: getInstanceProfileName
              InputPayload:
                InstanceId: '{{InstanceId}}'
              Script: |-
                import boto3

                def getInstanceProfileName(events, context):
                    ec2_client = boto3.client("ec2")
                    response = ec2_client.describe_instances(InstanceIds=[events["InstanceId"]])
                    if 'IamInstanceProfile' in response['Reservations'][0]['Instances'][0]:
                        return {'RoleName': response['Reservations'][0]['Instances'][0]['IamInstanceProfile']['Arn'].split('instance-profile/')[1]}
                    return {'RoleName': 'NoRoleFound'}
            outputs:
              - Name: existingInstanceProfileRoleName
                Selector: $.Payload.RoleName
                Type: String
            nextStep: branchIfProfileExists
          - name: branchIfProfileExists
            action: 'aws:branch'
            inputs:
              Choices:
                - NextStep: createRoleIfNotExists
                  Variable: '{{getExistingRoleName.existingInstanceProfileRoleName}}'
                  StringEquals: NoRoleFound
              Default: checkIfPolicyAttachAllowed
          - name: checkIfPolicyAttachAllowed
            action: 'aws:branch'
            inputs:
              Choices:
                - NextStep: getRoleFromInstanceProfile
                  Variable: '{{IsPolicyAttachAllowed}}'
                  StringEquals: 'true'
              Default: createRoleIfNotExists
          - name: getRoleFromInstanceProfile
            action: 'aws:executeAwsApi'
            inputs:
              Service: iam
              Api: GetInstanceProfile
              InstanceProfileName: '{{getExistingRoleName.existingInstanceProfileRoleName}}'
            outputs:
              - Name: existingRoleName
                Selector: '$.InstanceProfile.Roles[0].RoleName'
                Type: String
            nextStep: createBaselineOverridePolicyForExistingRole
          - name: createBaselineOverridePolicyForExistingRole
            action: 'aws:executeScript'
            inputs:
              Runtime: python3.8
              Handler: createBaselineOverridePolicy
              InputPayload:
                PolicyDocument: !Sub >-
                  {"Version": "2012-10-17","Statement": [{"Effect": "Allow","Action": "s3:GetObject","Resource": "arn:${AWS::Partition}:s3:::aws-quicksetup-patchpolicy-*"}]}
                Path: /ssm/quicksetup/patchpolicy/
                PolicyName: aws-quicksetup-patchpolicy-baselineoverrides-s3
              Script: "import boto3\nfrom botocore.exceptions import ClientError\niam_client = boto3.client('iam')            \ndef createBaselineOverridePolicy(events, context):\n    try:\n        policy_name = events['PolicyName']\n        iam_client.create_policy(PolicyName=policy_name,PolicyDocument=events['PolicyDocument'],Path=events['Path'])\n    except ClientError as e:\n        if e.response['Error']['Code'] == 'EntityAlreadyExists':\n            print('Policy already exists. Skipping creation.')\n        else:\n            raise e"
            onFailure: Abort
            description: >-
              Create the S3 Bucket Policy. If exception and EntityAlreadyExists, continue, else Abort.
            nextStep: attachBaselineOverridePolicyToExistingRole
          - name: attachBaselineOverridePolicyToExistingRole
            action: 'aws:executeAwsApi'
            inputs:
              Service: iam
              Api: AttachRolePolicy
              RoleName: '{{getRoleFromInstanceProfile.existingRoleName}}'
              PolicyArn: !Sub >-
                arn:${AWS::Partition}:iam::${AWS::AccountId}:policy/ssm/quicksetup/patchpolicy/aws-quicksetup-patchpolicy-baselineoverrides-s3
            description: Attach required managed policy to Instance Profile role.
            nextStep: attachAmazonSSMManagedInstanceCoreToExistingRole
            onFailure: Abort
          - name: attachAmazonSSMManagedInstanceCoreToExistingRole
            action: 'aws:executeAwsApi'
            inputs:
              Service: iam
              Api: AttachRolePolicy
              RoleName: '{{getRoleFromInstanceProfile.existingRoleName}}'
              PolicyArn: !Sub >-
                arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore
            nextStep: attachTagToExistingRole
          - name: attachTagToExistingRole
            action: 'aws:executeAwsApi'
            inputs:
              Service: iam
              Api: TagRole
              RoleName: '{{getRoleFromInstanceProfile.existingRoleName}}'
              Tags:
                - Key: !Sub 'QSConfigId-${QSConfigurationId}'
                  Value: !Sub '${QSConfigurationId}'
            isEnd: true
          - name: createRoleIfNotExists
            action: 'aws:executeScript'
            inputs:
              Runtime: python3.8
              Handler: createRoleIfNotExists
              InputPayload:
                Path: /
                RoleName: AmazonSSMRoleForInstancesQuickSetup
                AssumeRolePolicyDocument: >-
                  {"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":"ec2.amazonaws.com"},"Action":"sts:AssumeRole"}]}
                Description: EC2 role for SSM for Quick-Setup
              Script: "import boto3\nfrom botocore.exceptions import ClientError\niam_client = boto3.client('iam')            \ndef createRoleIfNotExists(events, context):\n    try:\n        iam_client.create_role(\n            Path=events['Path'],\n            RoleName=events['RoleName'],\n            AssumeRolePolicyDocument=events['AssumeRolePolicyDocument'],\n            Description=events['Description']\n        )\n    except ClientError as e:\n        if e.response['Error']['Code'] == 'EntityAlreadyExists':\n            print('Role already exists. Skipping creation.')\n        else:\n            raise e"
            onFailure: Abort
            description: >-
              Create AmazonSSMRoleForInstancesQuickSetup Role For SSM Quick Setup
            nextStep: assertRoleForInstanceProfileExists
          - name: assertRoleForInstanceProfileExists
            action: 'aws:assertAwsResourceProperty'
            inputs:
              Service: iam
              Api: GetRole
              PropertySelector: $.Role.RoleName
              DesiredValues:
                - AmazonSSMRoleForInstancesQuickSetup
              RoleName: AmazonSSMRoleForInstancesQuickSetup
            nextStep: createBaselineOverridePolicyForRole
          - name: createBaselineOverridePolicyForRole
            action: 'aws:executeScript'
            inputs:
              Runtime: python3.8
              Handler: createBaselineOverridePolicy
              InputPayload:
                PolicyDocument: !Sub >-
                  {"Version": "2012-10-17","Statement": [{"Effect": "Allow","Action": "s3:GetObject","Resource": "arn:${AWS::Partition}:s3:::aws-quicksetup-patchpolicy-*"}]}
                Path: /ssm/quicksetup/patchpolicy/
                PolicyName: aws-quicksetup-patchpolicy-baselineoverrides-s3
              Script: "import boto3\nfrom botocore.exceptions import ClientError\niam_client = boto3.client('iam')            \ndef createBaselineOverridePolicy(events, context):\n    try:\n        policy_name = events['PolicyName']\n        iam_client.create_policy(PolicyName=policy_name,PolicyDocument=events['PolicyDocument'],Path=events['Path'])\n    except ClientError as e:\n        if e.response['Error']['Code'] == 'EntityAlreadyExists':\n            print('Policy already exists. Skipping creation.')\n        else:\n            raise e"
            onFailure: Abort
            description: >-
              Create the S3 Bucket Policy. If exception and EntityAlreadyExists, continue, else Abort.
            nextStep: attachBaselineOverridePolicyToRole
          - name: attachBaselineOverridePolicyToRole
            action: 'aws:executeAwsApi'
            inputs:
              Service: iam
              Api: AttachRolePolicy
              RoleName: AmazonSSMRoleForInstancesQuickSetup
              PolicyArn: !Sub >-
                arn:${AWS::Partition}:iam::${AWS::AccountId}:policy/ssm/quicksetup/patchpolicy/aws-quicksetup-patchpolicy-baselineoverrides-s3
            description: Attach required managed policy to Instance Profile role.
            nextStep: attachTagToRole
            onFailure: Abort
          - name: attachTagToRole
            action: 'aws:executeAwsApi'
            inputs:
              Service: iam
              Api: TagRole
              RoleName: AmazonSSMRoleForInstancesQuickSetup
              Tags:
                - Key: !Sub 'QSConfigId-${QSConfigurationId}'
                  Value: !Sub '${QSConfigurationId}'
            nextStep: attachAmazonSSMManagedInstanceCoreToRole
          - name: attachAmazonSSMManagedInstanceCoreToRole
            action: 'aws:executeAwsApi'
            inputs:
              Service: iam
              Api: AttachRolePolicy
              RoleName: AmazonSSMRoleForInstancesQuickSetup
              PolicyArn: !Sub >-
                arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore
            nextStep: executeAttachIAMToInstance
          - name: executeAttachIAMToInstance
            action: 'aws:executeAutomation'
            maxAttempts: 10
            timeoutSeconds: 60
            inputs:
              DocumentName: AWS-AttachIAMToInstance
              RuntimeParameters:
                RoleName: AmazonSSMRoleForInstancesQuickSetup
                ForceReplace: false
                AutomationAssumeRole: '{{ AutomationAssumeRole }}'
                InstanceId: '{{ InstanceId }}'
            isEnd: true
      DocumentType: Automation
      TargetType: '/AWS::EC2::Instance'
      Name: !Sub 'AWSQuickSetup-CreateAndAttachIAMToEc2Node-${QSConfigurationId}'
  NameTagRemediationDocument:
    Type: 'AWS::SSM::Document'
    Properties:
      Content:
        description: >-
          Composite document for Quick Setup Naming  functionality. This document ensures that the appropriate tag is removed from all nodes in an account that are no longer a target of a Patch Policy.
        schemaVersion: '0.3'
        assumeRole: '{{AutomationAssumeRole}}'
        parameters:
          AutomationAssumeRole:
            type: String
          TargetType:
            type: String
          NameKey:
            type: String
          NameValue:
            type: String
          TargetValues:
            type: String
          Region:
            type: String
        mainSteps:
          - name: performRemediation
            action: 'aws:executeScript'
            inputs:
              Runtime: python3.8
              Handler: begin_remediation
              InputPayload:
                TargetType: '{{TargetType}}'
                NameKey: '{{NameKey}}'
                NameValue: '{{NameValue}}'
                Targets: '{{TargetValues}}'
                Region: '{{Region}}'
              Script: "import os\nimport resource\nimport boto3\nimport time\nimport json\n\ndef get_ssm_client(region):\n    return boto3.client('ssm', region_name=region)\n\ndef get_ec2_client(region):\n    return boto3.client('ec2', region_name=region)\n\ndef throw_exception_on_response_code(response):\n    response_code = str(response[\"ResponseMetadata\"][\"HTTPStatusCode\"])\n    if  response_code != \"200\":\n        raise Exception(\"Non-OK Status Code received: %s. Full Response: %s. Failing remediation document\"%(response_code, str(response)))\n\ndef remove_tag_from_resources(on_prem_instances, tag_key, region):\n    print(\"Removing tags from on prem instances: %s\"%(\",\".join(on_prem_instances)))\n    try:\n        for on_prem_instance in on_prem_instances:\n            response = get_ssm_client(region).remove_tags_from_resource(\n                ResourceType='ManagedInstance',\n                ResourceId=on_prem_instance,\n                TagKeys=[\n                    tag_key\n                ]\n            )\n            print(response)\n            throw_exception_on_response_code(response)\n            time.sleep(0.05)\n    except Exception as e:\n        print(\"Exception occurred removing tag for on prem instance %s: %s\"%(on_prem_instance, str(e)))\n        raise(e)\n\ndef delete_tags(ec2_instances, tag_key, tag_value, region):\n    print(\"Removing tags from ec2 instances: %s\"%(\",\".join(ec2_instances)))\n    try:\n        for i in range(0, len(ec2_instances), 250):\n            response = get_ec2_client(region).delete_tags(\n                DryRun=False,\n                Resources=ec2_instances[i:i+250],\n                Tags=[\n                    {\n                        'Key': tag_key,\n                        'Value': tag_value\n                    }\n                ]\n            )\n            throw_exception_on_response_code(response)\n            time.sleep(0.20)\n    except Exception as e:\n        print(\"Exception occurred removing tag from EC2 Instance %s: %s\"%(\", \".join(ec2_instances), str(e)))\n        raise (e)\n\ndef get_inventory(request, region):\n\n    try:\n        instance_ids = []\n        print(\"Calling get_inventory with request : \\n%s \\n\\n\"%(str(request)))\n        response = get_ssm_client(region).get_inventory(**request)\n        print(\"\\n\\n\")\n        print(response)\n        throw_exception_on_response_code(response)\n\n        [instance_ids.append(i[\"Id\"]) for i in response[\"Entities\"]]\n        next_token = None\n        if \"NextToken\" in response:\n            next_token = response[\"NextToken\"]\n\n        while next_token:\n            request[\"NextToken\"] = next_token\n            response = get_ssm_client(region).get_inventory(**request)\n            \n            throw_exception_on_response_code(response)\n            \n            [instance_ids.append(i[\"Id\"]) for i in response[\"Entities\"]]\n            \n            time.sleep(0.33)\n\n            if \"NextToken\" in response:\n                next_token = response[\"NextToken\"]\n            else:\n                next_token = None\n\n        return instance_ids\n    except Exception as e: \n        print(\"Something went wrong retrieving inventory with request: %s. \\\n         Exception: %s .\\n Failing remediation document. \"%(request, str(e)))\n        raise e\n\ndef remove_tags(list_of_instances, tag_key, tag_value, region):\n    mi = []\n    i = []\n    for instance in list_of_instances:\n        if (instance.startswith(\"mi\")):\n            mi.append(instance)\n        else:\n            i.append(instance)\n   \n    delete_tags(i, tag_key, tag_value, region)           \n    remove_tag_from_resources(mi, tag_key, region)\n\ndef get_tag_request(target):\n    tag_key = check_for_key(target, \"Key\")\n    \n    request = {\n        \"Filters\": [{\n            \"Key\": \"AWS:Tag.Key\", \n            \"Values\": [tag_key],\n            \"Type\": \"Equal\"\n\n        }]\n    }\n    # For the case where only a tag-key is targeted.\n    if \"Value\" in target:\n        tag_value = check_for_key(target, \"Value\")\n        request[\"Filters\"].append({\n            \"Key\": \"AWS:Tag.Value\", \n            \"Values\": [tag_value],\n            \"Type\": \"Equal\"\n        })\n\n    return request\n\ndef get_resource_group_request(target):\n    # for resource groups, the name is the Target key. e.g. '\"Target\": {\"Key\": \"ResourceGroupName\"}:\n    resource_group_name = check_for_key(target, \"Key\")\n    request = {    \n        \"Filters\": [{\n\n            \"Key\": \"AWS:ResourceGroup.Name\",\n            \"Values\": [resource_group_name],\n            \"Type\": \"Equal\"\n        }]\n    }\n    return request\n\ndef get_instance_ids_request(target):\n    request = {\"Filters\": []}\n    instance_ids = check_for_key(target, \"Key\").split(\",\")\n    for ids in range(0, len(instance_ids), 40):\n        request[\"Filters\"].append(            {\n                \"Key\": \"AWS:InstanceInformation.InstanceId\",\n                \"Values\": instance_ids[ids:ids+40],\n                \"Type\": \"Equal\"\n            })\n    return request\n\ndef check_for_key(hashmap, key):\n    if not key in hashmap:\n        raise Exception(\"The required key %s is not present. Failing.\"%(key))\n    else:\n        # return the value\n        return hashmap[key]\n\ndef get_target_request(target_type, target):\n    if target_type.lower() == \"tags\":\n        return get_tag_request(target)\n    elif target_type.lower() == \"instanceids\":\n        return get_instance_ids_request(target)\n    elif target_type.lower() == \"resourcegroups\":\n        return get_resource_group_request(target)\n    \n    raise Exception(\"Unable to understand the target type of the Patch Policy.\\\n         Received values was: %s. Failing remediation document. \"%(target_type))\n\ndef begin_remediation(event, context):\n    # Get all variables\n    target_type = check_for_key(event, \"TargetType\")\n\n    if target_type == \"*\":\n        return\n\n    name_key = check_for_key(event, \"NameKey\")\n    name_value = check_for_key(event, \"NameValue\")\n    region = check_for_key(event, \"Region\")\n\n    ## Add exception (to make it more robust)\n    target_dict = check_for_key(event, \"Targets\")\n\n    target = json.loads(target_dict)\n\n    # This filter will return all targets of the Patch Policy.\n    request = get_target_request(target_type, target)\n    target_instances = get_inventory(request, region)\n\n    # This will return targets that have the name tag\n    new_request = {\"Filters\": [{\n            \"Key\": \"AWS:Tag.Key\",\n            \"Values\": [name_key],\n            \"Type\": \"Equal\"\n        },\n        {\n            \"Key\": \"AWS:InstanceInformation.InstanceStatus\",\n            \"Values\": [\"Terminated\", \"ConnectionLost\"],\n            \"Type\": \"NotEqual\"\n        }]}\n\n    named_instances = get_inventory(new_request, region)\n\n    # 'get instances that are NOT a target of the Patch Policy but have the name tag'\n    instances_to_remove = set(named_instances) - set(target_instances)\n\n    # remove the tags\n    remove_tags(instances_to_remove, name_key, name_value, region)"
            outputs:
              - Name: existingInstanceProfileRoleName
                Selector: $.Payload.RoleName
                Type: String
            isEnd: true
      DocumentType: Automation
      Name: !Sub 'AWSQuickSetup-NameTagRemediation-${QSConfigurationId}'
  AddRemoveNameTagAutomationDocument:
    Type: 'AWS::SSM::Document'
    Properties:
      Content:
        description: Quick Setup document for remediating the name tag on EC2 instances.
        schemaVersion: '0.3'
        assumeRole: '{{AutomationAssumeRole}}'
        parameters:
          AutomationAssumeRole:
            type: String
          InstanceId:
            type: String
          QSConfigurationName:
            type: String
          QSConfigurationId:
            type: String
          TagAction:
            type: String
            allowedValues:
              - Add
              - Remove
        mainSteps:
          - name: branchOnInstanceType
            action: 'aws:branch'
            inputs:
              Choices:
                - NextStep: branchOnActionEC2
                  Variable: '{{InstanceId}}'
                  StartsWith: i-
                - NextStep: branchOnActionHybrid
                  Variable: '{{InstanceId}}'
                  StartsWith: mi-
            isEnd: true
          - name: branchOnActionEC2
            action: 'aws:branch'
            inputs:
              Choices:
                - NextStep: removeTagFromEC2Node
                  Variable: '{{TagAction}}'
                  StringEquals: Remove
                - NextStep: addTagToEC2Node
                  Variable: '{{TagAction}}'
                  StringEquals: Add
          - name: removeTagFromEC2Node
            action: 'aws:executeAwsApi'
            inputs:
              Service: ec2
              Api: DeleteTags
              Resources:
                - '{{InstanceId}}'
              Tags:
                - Key: 'QSConfigName-{{QSConfigurationId}}'
            onFailure: Abort
            isEnd: true
          - name: addTagToEC2Node
            action: 'aws:executeAwsApi'
            inputs:
              Service: ec2
              Api: CreateTags
              Resources:
                - '{{InstanceId}}'
              Tags:
                - Key: 'QSConfigName-{{QSConfigurationId}}'
                  Value: '{{QSConfigurationName}}'
            onFailure: Abort
            isEnd: true
          - name: branchOnActionHybrid
            action: 'aws:branch'
            inputs:
              Choices:
                - NextStep: removeTagFromHybridNode
                  Variable: '{{TagAction}}'
                  StartsWith: Remove
                - NextStep: addTagToHybridNode
                  Variable: '{{TagAction}}'
                  StringEquals: Add
          - name: removeTagFromHybridNode
            action: 'aws:executeAwsApi'
            inputs:
              Service: ssm
              Api: RemoveTagsFromResource
              ResourceType: ManagedInstance
              ResourceId: '{{InstanceId}}'
              TagKeys:
                - 'QSConfigName-{{QSConfigurationId}}'
            onFailure: Abort
            isEnd: true
          - name: addTagToHybridNode
            action: 'aws:executeAwsApi'
            inputs:
              Service: ssm
              Api: AddTagsToResource
              ResourceType: ManagedInstance
              ResourceId: '{{InstanceId}}'
              Tags:
                - Key: 'QSConfigName-{{QSConfigurationId}}'
                  Value: '{{QSConfigurationName}}'
            onFailure: Abort
            isEnd: true
      DocumentType: Automation
      Name: !Sub 'AWSQuickSetup-AddOrRemoveTag-PatchPolicy-${QSConfigurationId}'
      TargetType: /
  CreateAndAttachIAMToHybridInstanceDocument:
    Type: 'AWS::SSM::Document'
    Properties:
      Content:
        description: >-
          Composite document for Quick Setup IAM Management of hybrid instances. This document ensures IAM role for instance profile is created in account with all required policies for Hybrid nodes.
        schemaVersion: '0.3'
        assumeRole: '{{AutomationAssumeRole}}'
        parameters:
          AutomationAssumeRole:
            type: String
          InstanceId:
            type: String
          IsPolicyAttachAllowed:
            type: String
          AwsAccountId:
            type: String
          QSConfigurationId:
            type: String
          Region:
            type: String
        mainSteps:
          - name: branchOnInstanceType
            action: 'aws:branch'
            inputs:
              Choices:
                - NextStep: getExistingRoleName
                  Variable: '{{InstanceId}}'
                  StartsWith: mi-
            isEnd: true
          - name: getExistingRoleName
            action: 'aws:executeScript'
            inputs:
              Runtime: python3.8
              Handler: getRoleName
              InputPayload:
                InstanceId: '{{InstanceId}}'
                Region: '{{Region}}'
              Script: "import boto3\n\ndef getRoleName(events, context):\n    region = events[\"Region\"]\n    ssm_client = boto3.client(\"ssm\", region)\n    response = ssm_client.describe_instance_information(\n        InstanceInformationFilterList=[\n            {\n                'key': 'InstanceIds',\n                'valueSet': [\n                    events[\"InstanceId\"],\n                ]\n            },\n        ]\n    )\n   \n    if len (response[\"InstanceInformationList\"]) > 0 and \"IamRole\" in response[\"InstanceInformationList\"][0]: \n        return {'RoleName': response[\"InstanceInformationList\"][0][\"IamRole\"]}\n    return {'RoleName': 'NoRoleFound'}"
            outputs:
              - Name: roleName
                Selector: $.Payload.RoleName
                Type: String
            nextStep: branchIfProfileExists
          - name: branchIfProfileExists
            action: 'aws:branch'
            inputs:
              Choices:
                - NextStep: createRoleIfNotExists
                  Variable: '{{getExistingRoleName.roleName}}'
                  StringEquals: NoRoleFound
              Default: checkIfPolicyAttachAllowed
          - name: checkIfPolicyAttachAllowed
            action: 'aws:branch'
            inputs:
              Choices:
                - NextStep: createBaselineOverridePolicyForExistingRole
                  Variable: '{{IsPolicyAttachAllowed}}'
                  StringEquals: 'true'
              Default: createRoleIfNotExists
          - name: createBaselineOverridePolicyForExistingRole
            action: 'aws:executeScript'
            inputs:
              Runtime: python3.8
              Handler: createBaselineOverridePolicy
              InputPayload:
                PolicyDocument: !Sub >-
                  {"Version": "2012-10-17","Statement": [{"Effect": "Allow","Action": "s3:GetObject","Resource": "arn:${AWS::Partition}:s3:::aws-quicksetup-patchpolicy-*"}]}
                Path: /ssm/quicksetup/patchpolicy/
                PolicyName: aws-quicksetup-patchpolicy-baselineoverrides-s3
              Script: "import boto3\nfrom botocore.exceptions import ClientError\n\niam_client = boto3.client('iam')            \n\ndef createBaselineOverridePolicy(events, context):\n    try:\n        policy_name = events['PolicyName']\n        iam_client.create_policy(PolicyName=policy_name,PolicyDocument=events['PolicyDocument'],Path=events['Path'])\n    except ClientError as e:\n        if e.response['Error']['Code'] == 'EntityAlreadyExists':\n            print('Policy already exists. Skipping creation.')\n        else:\n            raise e"
            onFailure: Abort
            description: >-
              Create the S3 Bucket Policy. If exception and EntityAlreadyExists, continue, else Abort.
            nextStep: attachBaselineOverridePolicyToExistingRole
          - name: attachBaselineOverridePolicyToExistingRole
            action: 'aws:executeAwsApi'
            inputs:
              Service: iam
              Api: AttachRolePolicy
              RoleName: '{{getExistingRoleName.roleName}}'
              PolicyArn: !Sub >-
                arn:${AWS::Partition}:iam::${AWS::AccountId}:policy/ssm/quicksetup/patchpolicy/aws-quicksetup-patchpolicy-baselineoverrides-s3
            description: Attach required managed policy to Instance Profile role.
            nextStep: attachAmazonSSMManagedInstanceCoreToExistingRole
            onFailure: Abort
          - name: attachAmazonSSMManagedInstanceCoreToExistingRole
            action: 'aws:executeAwsApi'
            inputs:
              Service: iam
              Api: AttachRolePolicy
              RoleName: '{{getExistingRoleName.roleName}}'
              PolicyArn: !Sub >-
                arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore
            nextStep: attachTagToExistingRole
          - name: attachTagToExistingRole
            action: 'aws:executeAwsApi'
            inputs:
              Service: iam
              Api: TagRole
              RoleName: '{{getExistingRoleName.roleName}}'
              Tags:
                - Key: !Sub 'QSConfigId-${QSConfigurationId}'
                  Value: !Sub '${QSConfigurationId}'
            isEnd: true
          - name: createRoleIfNotExists
            action: 'aws:executeScript'
            inputs:
              Runtime: python3.8
              Handler: createRoleIfNotExists
              InputPayload:
                Path: /
                RoleName: AmazonSSMRoleForInstancesQuickSetup
                AssumeRolePolicyDocument: >-
                  {"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":"ssm.amazonaws.com"},"Action":"sts:AssumeRole"}]}
                Description: SSM Hybrid role for SSM for Quick-Setup
              Script: "import boto3\nfrom botocore.exceptions import ClientError\n\niam_client = boto3.client('iam')   \n\ndef createRoleIfNotExists(events, context):\n    try:\n        iam_client.create_role(Path=events['Path'], RoleName=events['RoleName'], AssumeRolePolicyDocument=events['AssumeRolePolicyDocument'], Description=events['Description'])\n    except ClientError as e:        \n        if e.response['Error']['Code'] == 'EntityAlreadyExists':\n            print('Role already exists. Skipping creation.')\n        else:            \n            raise e"
            onFailure: Abort
            description: >-
              Create AmazonSSMRoleForInstancesQuickSetup Role For SSM Quick Setup
            nextStep: assertRoleExists
          - name: assertRoleExists
            action: 'aws:assertAwsResourceProperty'
            inputs:
              Service: iam
              Api: GetRole
              PropertySelector: $.Role.RoleName
              DesiredValues:
                - AmazonSSMRoleForInstancesQuickSetup
              RoleName: AmazonSSMRoleForInstancesQuickSetup
            nextStep: createBaselineOverridePolicy
          - name: createBaselineOverridePolicy
            action: 'aws:executeScript'
            inputs:
              Runtime: python3.8
              Handler: createBaselineOverridePolicy
              InputPayload:
                PolicyDocument: !Sub >-
                  {"Version": "2012-10-17","Statement": [{"Effect": "Allow","Action": "s3:GetObject","Resource": "arn:${AWS::Partition}:s3:::aws-quicksetup-patchpolicy-*"}]}
                Path: /ssm/quicksetup/patchpolicy/
                PolicyName: aws-quicksetup-patchpolicy-baselineoverrides-s3
              Script: "import boto3\nfrom botocore.exceptions import ClientError\n\niam_client = boto3.client('iam')            \n\ndef createBaselineOverridePolicy(events, context):\n    try:\n        policy_name = events['PolicyName']\n        iam_client.create_policy(PolicyName=policy_name,PolicyDocument=events['PolicyDocument'],Path=events['Path'])\n    except ClientError as e:\n        if e.response['Error']['Code'] == 'EntityAlreadyExists':\n            print('Policy already exists. Skipping creation.')\n        else:\n            raise e"
            onFailure: Abort
            description: >-
              Create the S3 Bucket Policy. If exception and EntityAlreadyExists, continue, else Abort.
            nextStep: attachBaselineOverridePolicyToRole
          - name: attachBaselineOverridePolicyToRole
            action: 'aws:executeAwsApi'
            inputs:
              Service: iam
              Api: AttachRolePolicy
              RoleName: AmazonSSMRoleForInstancesQuickSetup
              PolicyArn: !Sub >-
                arn:${AWS::Partition}:iam::${AWS::AccountId}:policy/ssm/quicksetup/patchpolicy/aws-quicksetup-patchpolicy-baselineoverrides-s3
            description: Attach required managed policy to Instance Profile role.
            nextStep: attachAmazonSSMManagedInstanceCoreToRole
            onFailure: Abort
          - name: attachAmazonSSMManagedInstanceCoreToRole
            action: 'aws:executeAwsApi'
            inputs:
              Service: iam
              Api: AttachRolePolicy
              RoleName: AmazonSSMRoleForInstancesQuickSetup
              PolicyArn: !Sub >-
                arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore
            nextStep: attachTagToRole
          - name: attachTagToRole
            action: 'aws:executeAwsApi'
            inputs:
              Service: iam
              Api: TagRole
              RoleName: AmazonSSMRoleForInstancesQuickSetup
              Tags:
                - Key: !Sub 'QSConfigId-${QSConfigurationId}'
                  Value: !Sub '${QSConfigurationId}'
            nextStep: attachRoleToInstance
          - name: attachRoleToInstance
            action: 'aws:executeScript'
            inputs:
              Runtime: python3.8
              Handler: addRoleToHybridInstance
              InputPayload:
                RoleName: AmazonSSMRoleForInstancesQuickSetup
                InstanceId: '{{InstanceId}}'
                Region: '{{Region}}'
              Script: "import boto3\nfrom botocore.exceptions import ClientError\n\ndef addRoleToHybridInstance(events, context):\n    try:\n        ssm_client = boto3.client('ssm', region_name=events['Region'])   \n        ssm_client.update_managed_instance_role(InstanceId=events['InstanceId'],IamRole=events['RoleName'])\n    except ClientError as e:                   \n        raise e"
            onFailure: Abort
            description: >-
              Add AmazonSSMRoleForInstancesQuickSetup Role to the hybrid (mi-) instance.
            isEnd: true
      DocumentType: Automation
      Name: !Sub 'AWSQuickSetup-CreateAndAttachIAMToHybridNode-${QSConfigurationId}'
      TargetType: '/AWS::SSM::ManagedInstance'
    DependsOn: RoleForAutomation
Mappings:
  RulePackageArn:
    us-west-2:
      CVE: "arn:aws:inspector:us-west-2:758058086616:rulespackage/0-9hgA516p"
      CIS: "arn:aws:inspector:us-west-2:758058086616:rulespackage/0-H5hpSawc"
      Network: "arn:aws:inspector:us-west-2:758058086616:rulespackage/0-rD1z6dpl"
      Security: "arn:aws:inspector:us-west-2:758058086616:rulespackage/0-JJOtZiqQ"
      Runtime: "arn:aws:inspector:us-west-2:758058086616:rulespackage/0-vg5GGHSD"
    us-east-1:
      CVE: "arn:aws:inspector:us-east-1:316112463485:rulespackage/0-gEjTy7T7"
      CIS: "arn:aws:inspector:us-east-1:316112463485:rulespackage/0-rExsr2X8"
      Network: "arn:aws:inspector:us-east-1:316112463485:rulespackage/0-PmNV0Tcd"
      Security: "arn:aws:inspector:us-east-1:316112463485:rulespackage/0-R01qwB5Q"
      Runtime: "arn:aws:inspector:us-east-1:316112463485:rulespackage/0-gBONHN9h"
    us-east-2:
      CVE: "arn:aws:inspector:us-east-2:646659390643:rulespackage/0-JnA8Zp85"
      CIS: "arn:aws:inspector:us-east-2:646659390643:rulespackage/0-m8r61nnh"
      Network: "arn:aws:inspector:us-east-2:646659390643:rulespackage/0-cE4kTR30"
      Security: "arn:aws:inspector:us-east-2:646659390643:rulespackage/0-AxKmMHPX"
      Runtime: "arn:aws:inspector:us-east-2:646659390643:rulespackage/0-UCYZFKPV"
    us-west-1:
      CVE: "arn:aws:inspector:us-west-1:166987590008:rulespackage/0-TKgzoVOa"
      CIS: "arn:aws:inspector:us-west-1:166987590008:rulespackage/0-xUY8iRqX"
      Network: "arn:aws:inspector:us-west-1:166987590008:rulespackage/0-TxmXimXF"
      Security: "arn:aws:inspector:us-west-1:166987590008:rulespackage/0-byoQRFYm"
      Runtime: "arn:aws:inspector:us-west-1:166987590008:rulespackage/0-yeYxlt0x"
    ap-south-1:
      CVE: "arn:aws:inspector:ap-south-1:162588757376:rulespackage/0-LqnJE9dO"
      CIS: "arn:aws:inspector:ap-south-1:162588757376:rulespackage/0-PSUlX14m"
      Network: "arn:aws:inspector:ap-south-1:162588757376:rulespackage/0-YxKfjFu1"
      Security: "arn:aws:inspector:ap-south-1:162588757376:rulespackage/0-fs0IZZBj"
      Runtime: "arn:aws:inspector:ap-south-1:162588757376:rulespackage/0-EhMQZy6C"
    ap-southeast-2:
      CVE: "arn:aws:inspector:ap-southeast-2:454640832652:rulespackage/0-D5TGAxiR"
      CIS: "arn:aws:inspector:ap-southeast-2:454640832652:rulespackage/0-Vkd2Vxjq"
      Network: "arn:aws:inspector:ap-southeast-2:454640832652:rulespackage/0-FLcuV4Gz"
      Security: "arn:aws:inspector:ap-southeast-2:454640832652:rulespackage/0-asL6HRgN"
      Runtime: "arn:aws:inspector:ap-southeast-2:454640832652:rulespackage/0-P8Tel2Xj"
    ap-northeast-2:
      CVE: "arn:aws:inspector:ap-northeast-2:526946625049:rulespackage/0-PoGHMznc"
      CIS: "arn:aws:inspector:ap-northeast-2:526946625049:rulespackage/0-T9srhg1z"
      Network: "arn:aws:inspector:ap-northeast-2:526946625049:rulespackage/0-s3OmLzhL"
      Security: "arn:aws:inspector:ap-northeast-2:526946625049:rulespackage/0-2WRpmi4n"
      Runtime: "arn:aws:inspector:ap-northeast-2:526946625049:rulespackage/0-PoYq7lI7"
    ap-northeast-1:
      CVE: "arn:aws:inspector:ap-northeast-1:406045910587:rulespackage/0-gHP9oWNT"
      CIS: "arn:aws:inspector:ap-northeast-1:406045910587:rulespackage/0-7WNjqgGu"
      Network: "arn:aws:inspector:ap-northeast-1:406045910587:rulespackage/0-YI95DVd7"
      Security: "arn:aws:inspector:ap-northeast-1:406045910587:rulespackage/0-bBUQnxMq"
      Runtime: "arn:aws:inspector:ap-northeast-1:406045910587:rulespackage/0-knGBhqEu"
    eu-west-1:
      CVE: "arn:aws:inspector:eu-west-1:357557129151:rulespackage/0-ubA5XvBh"
      CIS: "arn:aws:inspector:eu-west-1:357557129151:rulespackage/0-sJBhCr0F"
      Network: "arn:aws:inspector:eu-west-1:357557129151:rulespackage/0-SPzU33xe"
      Security: "arn:aws:inspector:eu-west-1:357557129151:rulespackage/0-SnojL3Z6"
      Runtime: "arn:aws:inspector:eu-west-1:357557129151:rulespackage/0-lLmwe1zd"
    eu-central-1:
      CVE: "arn:aws:inspector:eu-central-1:537503971621:rulespackage/0-wNqHa8M9"
      CIS: "arn:aws:inspector:eu-central-1:537503971621:rulespackage/0-nZrAVuv8"
      Network: "arn:aws:inspector:eu-central-1:537503971621:rulespackage/0-6yunpJ91"
      Security: "arn:aws:inspector:eu-central-1:537503971621:rulespackage/0-ZujVHEPB"
      Runtime: "arn:aws:inspector:eu-central-1:537503971621:rulespackage/0-0GMUM6fg"
    us-gov-east-1:
      CVE: "arn:aws-us-gov:inspector:us-gov-east-1:206278770380:rulespackage/0-3IFKFuOb"
      CIS: "arn:aws-us-gov:inspector:us-gov-east-1:206278770380:rulespackage/0-pTLCdIww"
      Security: "arn:aws-us-gov:inspector:us-gov-east-1:206278770380:rulespackage/0-vlgEGcVD"
      Runtime: "arn:aws-us-gov:inspector:us-gov-east-1:206278770380:rulespackage/0-850TmCFX"
    us-gov-west-1:
      CVE: "arn:aws-us-gov:inspector:us-gov-west-1:850862329162:rulespackage/0-4oQgcI4G"
      CIS: "arn:aws-us-gov:inspector:us-gov-west-1:850862329162:rulespackage/0-Ac4CFOuc"
      Security: "arn:aws-us-gov:inspector:us-gov-west-1:850862329162:rulespackage/0-rOTGqe5G"
      Runtime: "arn:aws-us-gov:inspector:us-gov-west-1:850862329162:rulespackage/0-JMyjuzoW"
